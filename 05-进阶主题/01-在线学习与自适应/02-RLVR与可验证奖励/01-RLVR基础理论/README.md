# RLVR 基础理论

**Authors:** Damon Li

## 1. 可验证奖励的形式化定义

在 RLVR 中，奖励函数 $R(s, a)$ 由一个可验证的、确定性的外部工具（Verifier）定义。

$$R(s, a) = \text{Verifier}(\text{Execute}(s, a))$$

其中：
- $s$: 当前状态（如代码问题）
- $a$: 采取的动作（如生成的代码）
- $\text{Execute}(s, a)$: 执行动作后的结果
- $\text{Verifier}(\cdot)$: 验证器，返回一个标量奖励（通常为 0 或 1）

## 2. RLVR 与 RLHF 的对比

| 维度 | RLVR | RLHF |
|:---|:---|:---|
| 奖励来源 | 自动化、客观、可验证 | 人类反馈、主观 |
| 成本 | 低（自动验证） | 高（需要人工标注） |
| 适用场景 | 结果可验证的任务 | 主观性强的任务 |
| 可扩展性 | 高 | 低 |
| 奖励 hacking | 风险低 | 风险高 |

## 3. RLVR 的适用场景

- **代码生成**: 使用编译器、单元测试作为验证器
- **数学推理**: 使用符号计算工具（如 SymPy）作为验证器
- **事实问答**: 使用知识库查询结果作为验证器
- **SQL 生成**: 使用数据库执行结果作为验证器
